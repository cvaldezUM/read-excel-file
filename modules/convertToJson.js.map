{"version":3,"sources":["../source/convertToJson.js"],"names":["parseDate","Integer","isInteger","URL","isURL","Email","isEmail","DEFAULT_OPTIONS","isColumnOriented","data","schema","options","rowMap","validateSchema","transpose","columns","results","errors","i","length","result","read","originalRow","push","error","row","rows","rowIndex","object","key","schemaEntry","isNestedSchema","type","Array","isArray","rawValue","indexOf","undefined","value","notEmpty","array","parseArray","map","_value","parseValue","required","column","prop","Object","keys","parse","parseCustomValue","parseValueOfType","Error","JSON","stringify","validate","message","parsed","String","Number","isFinite","parseFloat","Date","parseInt","date","properties","Boolean","name","getBlock","string","endCharacter","startIndex","substring","character","block","blocks","index","trim","_","entry"],"mappings":"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","file":"convertToJson.js","sourcesContent":["import parseDate from './parseDate'\r\nimport Integer, { isInteger } from './types/Integer'\r\nimport URL, { isURL } from './types/URL'\r\nimport Email, { isEmail } from './types/Email'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {string[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i - 1, columns, errors, options)\r\n    if (result) {\r\n      result.originalRow = (i + 1);\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      error.row = rowMap[error.row] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors, options) {\r\n  const object = {}\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n    let value\r\n    let error\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry, options)\r\n        error = result.error\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n    if (!error && value === null && schemaEntry.required) {\r\n      error = 'required'\r\n    }\r\n    if (error) {\r\n      error = {\r\n        error,\r\n        row: rowIndex + 1,\r\n        column: key,\r\n        value\r\n      }\r\n      if (schemaEntry.type) {\r\n        error.type = schemaEntry.type\r\n      }\r\n      errors.push(error)\r\n    } else if (value !== null) {\r\n      object[schemaEntry.prop] = value\r\n    }\r\n  }\r\n  if (Object.keys(object).length > 0) {\r\n    return object\r\n  }\r\n  return null\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(value, Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options)\r\n  } else {\r\n    throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null && schemaEntry.validate) {\r\n    try {\r\n      schemaEntry.validate(result.value)\r\n    } catch (error) {\r\n      return { error: error.message }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {string} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    let parsed = parse(value)\r\n    if (parsed === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value: parsed }\r\n  } catch (error) {\r\n    return { error: error.message }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      return { value }\r\n\r\n    case Number:\r\n    case 'Integer':\r\n    case Integer:\r\n      // The global isFinite() function determines\r\n      // whether the passed value is a finite number.\r\n      // If  needed, the parameter is first converted to a number.\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      if (type === Integer && !isInteger(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      // Convert strings to numbers.\r\n      // Just an additional feature.\r\n      // Won't happen when called from `readXlsx()`.\r\n      if (typeof value === 'string') {\r\n        value = parseFloat(value)\r\n      }\r\n      return { value }\r\n\r\n    case 'URL':\r\n    case URL:\r\n      if (!isURL(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case 'Email':\r\n    case Email:\r\n      if (!isEmail(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case Date:\r\n      // XLSX has no specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      if (value instanceof Date) {\r\n        return { value }\r\n      }\r\n      if (typeof value === 'number') {\r\n        if (!isFinite(value)) {\r\n          return { error: 'invalid' }\r\n        }\r\n        value = parseInt(value)\r\n        const date = parseDate(value, options.properties)\r\n        if (!date) {\r\n          return { error: 'invalid' }\r\n        }\r\n        return { value: date }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Boolean:\r\n      if (typeof value === 'boolean') {\r\n        return { value }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    default:\r\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}"]}